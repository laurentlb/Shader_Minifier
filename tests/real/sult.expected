// Generated with  (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SULT_EXPECTED_
# define SULT_EXPECTED_
# define VAR_resolution "r"
# define VAR_time "c"

const char *sult_frag =
 "float v=5.,z=.9,x=0.,a=90.,y=0.;"
 "vec3 m=vec3(1),n=vec3(0,0,1),s=vec3(0,0,1.5);"
 "uniform vec2 r;"
 "uniform float c;"
 "vec3 rotatey(vec3 v,float m)"
 "{"
   "return vec3(v.x*cos(m)+v.z*sin(m),v.y,v.z*cos(m)-v.x*sin(m));"
 "}"
 "float f=0.,w=10.;"
 "float e(vec3 m)"
 "{"
   "float y=c,a,g=0.,C,z,F;"
   "vec3 r;"
   "m+=(sin(m.zxy*1.7+y)+sin(m.yzx+y*3.))*.2;"
   "g=v<6.?"
     "length(m.xyz*vec3(1,1,.1)-vec3(0,-.1,y*.15-.3))-.34:"
     "length(m.xy+vec2(0,.7))-.3+(sin(m.z*17.+y*.6)+sin(m.z*2.)*6.)*.01;"
   "m.xy=vec2(atan(m.x,m.y)*1.113,1.6-length(m.xy)-sin(y*2.)*.3);"
   "r=fract(m.xzz+.5).xyz-.5;"
   "r.y=(m.y-.35)*1.3;"
   "a=max(abs(m.y-.3)-.05,abs(length(fract(m.xz)-.5)-.4)-.03);"
   "f=step(g,a);"
   "return min(min(a,g),m.y-.2);"
 "}"
 "vec3 d=vec3(.19,.2,.24),C=vec3(1),F=vec3(.45,.01,0),g=vec3(.17,0,0);"
 "void main()"
 "{"
   "vec2 l=-1.+2.*gl_FragCoord.xy/r.xy;"
   "vec3 I=normalize(rotatey(rotatey(vec3(l.y*z,l.x*z*1.33,1),-x*.035).yxz,(a+y*c)*.035)),H=n+s*c;"
   "float u=1.,E=0.,i,B,A=0.,D,p,G,J;"
   "vec3 K=vec3(.01,0,0),L=K.yyy,M;"
   "for(;u>.1;)"
     "{"
       "for(i=A,B=1.;i<w&&B>.005;i+=B)"
         "B=e(H+I*i);"
       "if(i<w)"
         "H+=I*i,D=e(H),G=f,M=normalize(-vec3(D-e(H+K.xyy),D-e(H+K.yxy),D-e(H+K.yyx))),p=clamp(e(H+M*.05)*4.+e(H+M*.1)*2.+.5,.1,1.),E=G*.3,M=normalize(M+step(4.,v)*f*sin(H.yzx*40.)*.05),I=reflect(I,M),J=clamp(dot(normalize(m),M),0.,1.),M=mix(mix(d,C,J),F*(J+.2),G)+vec3(.7*pow(clamp(dot(normalize(m),I),0.,1.),12.)),L+=u*mix(M*p,g,i/w),u*=E*(1.-i/w),A=.1;"
       "else"
         " L+=u*g,u=0.;"
     "}"
   "gl_FragColor.xyz=L;"
   "gl_FragColor.w=1.;"
 "}";

#endif // SULT_EXPECTED_
