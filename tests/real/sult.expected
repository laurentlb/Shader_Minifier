// Generated with  (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SULT_EXPECTED_
# define SULT_EXPECTED_
# define VAR_resolution "r"
# define VAR_time "m"

const char *sult_frag =
 "float v=5.,z=.9,x=0.,a=90.,y=0.;"
 "vec3 d=vec3(1),n=vec3(0,0,1),s=vec3(0,0,1.5);"
 "uniform vec2 r;"
 "uniform float m;"
 "vec3 rotatey(vec3 v,float d)"
 "{"
   "return vec3(v.x*cos(d)+v.z*sin(d),v.y,v.z*cos(d)-v.x*sin(d));"
 "}"
 "float f=0.,k=10.;"
 "float e(vec3 d)"
 "{"
   "float y=m,k,a=0.,c,w,C;"
   "vec3 r;"
   "d+=(sin(d.zxy*1.7+y)+sin(d.yzx+y*3.))*.2;"
   "a=v<6.?"
     "length(d.xyz*vec3(1,1,.1)-vec3(0,-.1,y*.15-.3))-.34:"
     "length(d.xy+vec2(0,.7))-.3+(sin(d.z*17.+y*.6)+sin(d.z*2.)*6.)*.01;"
   "d.xy=vec2(atan(d.x,d.y)*1.113,1.6-length(d.xy)-sin(y*2.)*.3);"
   "r=fract(d.xzz+.5).xyz-.5;"
   "r.y=(d.y-.35)*1.3;"
   "k=max(abs(d.y-.3)-.05,abs(length(fract(d.xz)-.5)-.4)-.03);"
   "f=step(a,k);"
   "return min(min(k,a),d.y-.2);"
 "}"
 "vec3 diffdark=vec3(.19,.2,.24),w=vec3(1),C=vec3(.45,.01,0),c=vec3(.17,0,0);"
 "void main()"
 "{"
   "vec2 l=-1.+2.*gl_FragCoord.xy/r.xy;"
   "vec3 F=normalize(rotatey(rotatey(vec3(l.y*z,l.x*z*1.33,1),-x*.035).yxz,(a+y*m)*.035)),J=n+s*m;"
   "float u=1.,H=0.,g,E,D=0.,B,p,A,G;"
   "vec3 I=vec3(.01,0,0),K=I.yyy,L;"
   "for(;u>.1;)"
     "{"
       "for(g=D,E=1.;g<k&&E>.005;g+=E)"
         "E=e(J+F*g);"
       "if(g<k)"
         "J+=F*g,B=e(J),A=f,L=normalize(-vec3(B-e(J+I.xyy),B-e(J+I.yxy),B-e(J+I.yyx))),p=clamp(e(J+L*.05)*4.+e(J+L*.1)*2.+.5,.1,1.),H=A*.3,L=normalize(L+step(4.,v)*f*sin(J.yzx*40.)*.05),F=reflect(F,L),G=clamp(dot(normalize(d),L),0.,1.),L=mix(mix(diffdark,w,G),C*(G+.2),A)+vec3(.7*pow(clamp(dot(normalize(d),F),0.,1.),12.)),K+=u*mix(L*p,c,g/k),u*=H*(1.-g/k),D=.1;"
       "else"
         " K+=u*c,u=0.;"
     "}"
   "gl_FragColor.xyz=K;"
   "gl_FragColor.w=1.;"
 "}";

#endif // SULT_EXPECTED_
