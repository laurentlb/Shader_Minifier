// Generated with  (https://github.com/laurentlb/Shader_Minifier/)
#ifndef TO_THE_ROAD_OF_RIBBON_EXPECTED_
# define TO_THE_ROAD_OF_RIBBON_EXPECTED_

const char *to_the_road_of_ribbon_frag =
 "uniform vec2 resolution;"
 "uniform float time;"
 "float oa(vec3 t)"
 "{"
   "return cos(t.x)+cos(t.y*1.5)+cos(t.z)+cos(t.y*20.)*.05;"
 "}"
 "float ob(vec3 t)"
 "{"
   "return length(max(abs(t-vec3(cos(t.z*1.5)*.3,-.5+cos(t.z)*.2,0))-vec3(.125,.02,time+3.),vec3(0)));"
 "}"
 "float o(vec3 t)"
 "{"
   "return min(oa(t),ob(t));"
 "}"
 "vec3 gn(vec3 t)"
 "{"
   "vec3 c=vec3(.01,0,0);"
   "return normalize(vec3(o(t+c.xyy),o(t+c.yxy),o(t+c.yyx)));"
 "}"
 "void main()"
 "{"
   "vec2 t=-1.+2.*gl_FragCoord.xy/resolution.xy;"
   "t.x*=resolution.x/resolution.y;"
   "vec4 v=vec4(1);"
   "vec3 m=vec3(sin(time)*.5,cos(time*.5)*.25+.25,time),o=normalize(vec3(t.x*1.6,t.y,1)),c=m,f;"
   "float e=0.;"
   "for(int r=0;r<64;r++)"
     "e=o(c),c+=e*o;"
   "f=c;"
   "float r=length(c-m)*.02;"
   "o=reflect(o,gn(c));"
   "c+=o;"
   "for(int g=0;g<64;g++)"
     "e=o(c),c+=e*o;"
   "v=max(dot(gn(c),vec3(.1,.1,0)),0.)+vec4(.3,cos(time*.5)*.5+.5,sin(time*.5)*.5+.5,1)*min(length(c-m)*.04,1.);"
   "if(oa(f)>ob(f))"
     "v=mix(v,vec4(cos(time*.3)*.5+.5,cos(time*.2)*.5+.5,sin(time*.3)*.5+.5,1),.3);"
   "v=(v+vec4(r)+(1.-min(f.y+1.9,1.))*vec4(1,.8,.7,1))*min(time*.5,1.);"
   "gl_FragColor=vec4(v.xyz,1);"
 "}";

#endif // TO_THE_ROAD_OF_RIBBON_EXPECTED_
